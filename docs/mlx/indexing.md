Curator's note: Prefer the human-authored MLX guides for clarity. - ../docs\\\\\\\_curated/README.md - ../docs\\\\\\\_curated/PYTORCH\\\\\\\_DISSONANCE.md - ../docs\\\\\\\_curated/NUMPY\\\\\\\_USERS.md - ../docs\\\\\\\_curated/COMMON\\\\\\\_PITFALLS.md \\\\## Curated Notes - \\\\\\\`mx.take(x, indices, axis=...)\\\\\\\` gathers by index along a chosen axis; pair with \\\\\\\`mx.put\\\\\\\_along\\\\\\\_axis\\\\\\\` for scatter‑style updates. - \\\\\\\`mx.slice\\\\\\\`/\\\\\\\`mx.slice\\\\\\\_update\\\\\\\` take MLX array for \\\\\\\`start\\\\\\\_indices\\\\\\\` and Python list/tuple for \\\\\\\`axes\\\\\\\`/\\\\\\\`slice\\\\\\\_size\\\\\\\`. - Non‑contiguous slice views can impact heavy kernels; call \\\\\\\`mx.contiguous(view)\\\\\\\` when performance matters. - Device control: indexing ops do not take a \\\\\\\`device=\\\\\\\` argument; placement follows the current default device or per‑op \\\\\\\`stream\\\\\\\` where available. ### Examples \\\\\\\`\\\\\\\`\\\\\\\`python import mlx.core as mx a = mx.arange(12).reshape(3, 4) # slice\\\\\\\_update: write a 2x2 block at (0,1) start = mx.array(\\\\\\\[0, 1\\\\\\\]) axes = \\\\\\\[0, 1\\\\\\\] update = mx.array(\\\\\\\[\\\\\\\[10, 11\\\\\\\], \\\\\\\[12, 13\\\\\\\]\\\\\\\]) b = mx.slice\\\\\\\_update(a, update, start, axes) # put\\\\\\\_along\\\\\\\_axis: scatter values along an axis x = mx.zeros((3, 4)) idx = mx.array(\\\\\\\[\\\\\\\[1, 3, 0, 2\\\\\\\], \\\\\\\[0, 1, 2, 3\\\\\\\], \\\\\\\[3, 2, 1, 0\\\\\\\]\\\\\\\]) vals = mx.arange(12).reshape(3, 4) y = mx.put\\\\\\\_along\\\\\\\_axis(x, idx, vals, axis=1) \\\\\\\`\\\\\\\`\\\\\\\` \\\[\\\](https://github.com/ml-explore/mlx "Source repository")\\\\- \\\[.rst\\\](https://ml-explore.github.io/mlx/build/html/\\\_sources/usage/indexing.rst "Download source file") - .pdf # Indexing Arrays ## Contents \\\\- \\\[Differences from NumPy\\\](https://ml-explore.github.io/mlx/build/html/#differences-from-numpy) - \\\[In Place Updates\\\](https://ml-explore.github.io/mlx/build/html/#in-place-updates) # Indexing Arrays For the most part, indexing an MLX \\\[\\\`\\\`array\\\`\\\`\\\](https://ml-explore.github.io/mlx/build/html/python/\\\_autosummary/mlx.core.array.html#mlx.core.array "mlx.core.array") works the same as indexing a NumPy \\\[\\\`\\\`numpy.ndarray\\\`\\\`\\\](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.2)"). See the \\\[NumPy documentation\\\](https://numpy.org/doc/stable/user/basics.indexing.html) for more details on how that works. For example, you can use regular integers and slices (\\\[\\\`\\\`slice\\\`\\\`\\\](https://ml-explore.github.io/mlx/build/html/python/\\\_autosummary/mlx.core.slice.html#mlx.core.slice "mlx.core.slice")) to index arrays: \\\`\\\`\\\`shell > arr = mx.arange(10) > arr\\\[3\\\] array(3, dtype=int32) > arr\\\[-2\\\] # negative indexing works array(8, dtype=int32) > arr\\\[2:8:2\\\] # start, stop, stride array(\\\[2, 4, 6\\\], dtype=int32) \\\`\\\`\\\` For multi-dimensional arrays, the \\\`\\\\\\\`...\\\\\\\`\\\` or \\\[\\\`\\\`Ellipsis\\\`\\\`\\\](https://docs.python.org/3/library/constants.html#Ellipsis "(in Python v3.13)") syntax works as in NumPy: \\\`\\\`\\\`shell > arr = mx.arange(8).reshape(2, 2, 2) > arr\\\[:, :, 0\\\] array(3, dtype=int32) array(\\\[\\\[0, 2\\\], \\\[4, 6\\\]\\\], dtype=int32 > arr\\\[..., 0\\\] array(\\\[\\\[0, 2\\\], \\\[4, 6\\\]\\\], dtype=int32 \\\`\\\`\\\` You can index with \\\`\\\\\\\`None\\\\\\\`\\\` to create a new axis: \\\`\\\`\\\`shell > arr = mx.arange(8) > arr.shape \\\[8\\\] > arr\\\[None\\\].shape \\\[1, 8\\\] \\\`\\\`\\\` You can also use an \\\[\\\`\\\`array\\\`\\\`\\\](https://ml-explore.github.io/mlx/build/html/python/\\\_autosummary/mlx.core.array.html#mlx.core.array "mlx.core.array") to index another \\\[\\\`\\\`array\\\`\\\`\\\](https://ml-explore.github.io/mlx/build/html/python/\\\_autosummary/mlx.core.array.html#mlx.core.array "mlx.core.array"): \\\`\\\`\\\`shell > arr = mx.arange(10) > idx = mx.array(\\\[5, 7\\\]) > arr\\\[idx\\\] array(\\\[5, 7\\\], dtype=int32) \\\`\\\`\\\` Mixing and matching integers, \\\[\\\`\\\`slice\\\`\\\`\\\](https://ml-explore.github.io/mlx/build/html/python/\\\_autosummary/mlx.core.slice.html#mlx.core.slice "mlx.core.slice"), \\\`\\\\\\\`...\\\\\\\`\\\`, and \\\[\\\`\\\`array\\\`\\\`\\\](https://ml-explore.github.io/mlx/build/html/python/\\\_autosummary/mlx.core.array.html#mlx.core.array "mlx.core.array") indices works just as in NumPy. Other functions which may be useful for indexing arrays are \\\[\\\`\\\`take()\\\`\\\`\\\](https://ml-explore.github.io/mlx/build/html/python/\\\_autosummary/mlx.core.take.html#mlx.core.take "mlx.core.take") and \\\[\\\`\\\`take\\\_along\\\_axis()\\\`\\\`\\\](https://ml-explore.github.io/mlx/build/html/python/\\\_autosummary/mlx.core.take\\\_along\\\_axis.html#mlx.core.take\\\_along\\\_axis "mlx.core.take\\\_along\\\_axis"). ## Differences from NumPy Note MLX indexing is different from NumPy indexing in two important ways: - Indexing does not perform bounds checking. Indexing out of bounds is undefined behavior. - Boolean mask based indexing is not yet supported. The reason for the lack of bounds checking is that exceptions cannot propagate from the GPU. Performing bounds checking for array indices before launching the kernel would be extremely inefficient. Indexing with boolean masks is something that MLX may support in the future. In general, MLX has limited support for operations for which output \\\\\\\*shapes\\\\\\\* are dependent on input \\\\\\\*data\\\\\\\*. Other examples of these types of operations which MLX does not yet support include \\\[\\\`\\\`numpy.nonzero()\\\`\\\`\\\](https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero "(in NumPy v2.2)") and the single input version of \\\[\\\`\\\`numpy.where()\\\`\\\`\\\](https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where "(in NumPy v2.2)"). ## In Place Updates In place updates to indexed arrays are possible in MLX. For example: \\\`\\\`\\\`shell > a = mx.array(\\\[1, 2, 3\\\]) > a\\\[2\\\] = 0 > a array(\\\[1, 2, 0\\\], dtype=int32) \\\`\\\`\\\` Just as in NumPy, in place updates will be reflected in all references to the same array: \\\`\\\`\\\`shell > a = mx.array(\\\[1, 2, 3\\\]) > b = a > b\\\[2\\\] = 0 > b array(\\\[1, 2, 0\\\], dtype=int32) > a array(\\\[1, 2, 0\\\], dtype=int32) \\\`\\\`\\\` Transformations of functions which use in-place updates are allowed and work as expected. For example: \\\`\\\`\\\`python def fun(x, idx): x\\\[idx\\\] = 2.0 return x.sum() dfdx = mx.grad(fun)(mx.array(\\\[1.0, 2.0, 3.0\\\]), mx.array(\\\[1\\\])) print(dfdx) # Prints: array(\\\[1, 0, 1\\\], dtype=float32) \\\`\\\`\\\` In the above \\\`\\\\\\\`dfdx\\\\\\\`\\\` will have the correct gradient, namely zeros at \\\`\\\\\\\`idx\\\\\\\`\\\` and ones elsewhere. \\\[\\\](https://ml-explore.github.io/mlx/build/html/usage/unified\\\_memory.html "previous page") previous Unified Memory \\\[\\\](https://ml-explore.github.io/mlx/build/html/usage/saving\\\_and\\\_loading.html "next page") next Saving and Loading Arrays Contents \\\\- \\\[Differences from NumPy\\\](https://ml-explore.github.io/mlx/build/html/#differences-from-numpy) - \\\[In Place Updates\\\](https://ml-explore.github.io/mlx/build/html/#in-place-updates) By MLX Contributors © Copyright 2023, MLX Contributors.
